# Аналитический отчет по особенностям формирования структур данных: бинарная куча, биномиальная куча, куча Фибоначчи и хеш-таблицы на языках Python, C++ и Java (Попычко Владислав, УИБО-10-24)

## 1. Бинарная куча
Представляет собой полное бинарное дерево, организованное по принципу min-heap (родитель меньше потомков) или max-heap (родитель больше потомков). Для хранения используется массив. Это основа для реализации приоритетных очередей.

## 2. Биномиальная куча
Состоит из набора биномиальных деревьев, каждое из которых подчиняется свойству кучи. Её ключевое преимущество — эффективное слияние, хотя структура сложнее, чем у бинарной кучи.

## 3. Куча Фибоначчи
Формируется из коллекции деревьев (не обязательно биномиальных). Её главная особенность — амортизированная константная сложность операции уменьшения ключа. Это самая сложная в реализации куча, но она предлагает наилучшую амортизированную производительность для ряда операций.

## 4. Хеш-таблицы
Это структура данных типа «ключ-значение», где для быстрого доступа к элементу хеш-функция преобразует ключ в индекс массива. Коллизии (совпадение индексов) разрешаются с помощью метода цепочек или открытой адресации.

## Python
- Бинарная куча: heapq – heapify(), heappush(), heappop()
- Биномиальная куча: нет встроенной поддержки
- Куча Фибоначчи: нет встроенной поддержки
- Хеш-таблицы: dict – set(), get(), remove(), keys(), values()
## C++
- Бинарная куча: вектор + методы: heapifyUp(), heapifyDown(), insert(),  extractMin()
- Биномиальная куча: ручная реализация – Union(), Merge(), Insert(), Extract_Min()
- Куча Фибоначчи: ручная реализация – insert(), unite(), extractMin(), decreaseKey()
- Хеш-таблицы: std::unordered_map – insert(), find(), erase(); ручная реализация с цепочками
## Java
- Бинарная куча: массив + методы: add(), pop(), getTop(), heapify
- Биномиальная куча: ручная реализация – insert(), deleteMin(), meld(), decreaseKey()
- Куча Фибоначчи: нет встроенной реализации
- Хеш-таблицы: Hashtable, HashMap – put(), get(),remove(), containsKey()

